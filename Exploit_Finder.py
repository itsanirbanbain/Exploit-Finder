import re
import os
import json
import random
import tarfile
import colorama
import datetime
import requests
import random
import textwrap
from colorama import Fore
from pathlib import Path
from pwn import *
from prettytable import PrettyTable
from random_user_agent.user_agent import UserAgent
from random_user_agent.params import SoftwareName, OperatingSystem

exploit_finder_art = """
 ___                 _              _       ___                  _              
(  _`\              (_ )         _ ( )_    (  _`\  _            ( )             
| (_(_)       _ _    | |    _   (_)| ,_)   | (_(_)(_)  ___     _| |   __   _ __ 
|  _)_ (`\/')( '_`\  | |  /'_`\ | || |     |  _)  | |/' _ `\ /'_` | /'__`\( '__)
| (_( ) >  < | (_) ) | | ( (_) )| || |_    | |    | || ( ) |( (_| |(  ___/| |   
(____/'(_/\_)| ,__/'(___)`\___/'(_)`\__)   (_)    (_)(_) (_)`\__,_)`\____)(_)   
             | |                                                                
             (_)                                                                  
"""
author_info = "Author: Anirban Bain"
github_info = "GitHub: https://github.com/itsanirbanbain"
usages = """

-- USAGES --
[+] To update the local database : update
[+] To get latest critical CVE : critical
[+] To search any keyword : search <keyword> | Example : search Cacti
[+] To get exploits for Common Vulnerabilities and Exposures (CVE) : get <CVE-ID> | Example : get CVE-2023-38646
[+] To get exploits for Russian Data Bank of Information Security Threats (BDU) : get <BDU-ID> | Example : get BDU:2024-00390
[+] To get exploits for China National Vulnerability Database (CNVD) : get <CNVD-ID> | Example : get CNVD-2024-02713
[+] To get exploits for Japan Vulnerability Notes iPedia (JVNDB) : get <JVNDB-ID> | Example : get JVNDB-2023-006199
[+] To get exploits for GitHub Security Advisories (GHSA) : get <GHSA-ID> | Example : get GHSA-wfh5-x68w-hvw2
[+] To get exploits for Exploit Database (EDB) : get <EDB-ID> | Example : get EDB-10102
[+] To get exploits for Zero Day Initiative (ZDI) : get <ZDI-ID> | Example : ZDI-23-1714
[+] To get exploits for Packet Storm Security (PSS) : get <PSS-ID> | Example : PSS-170615
[+] To get exploits for World Laboratory of Bugtraq (WLB) : get <WLB-ID> | Example : WLB-2024010058
[+] To get exploits for WP Engine WPScan (WPSCAN) : get <WPSCAN-ID> | Example : WPSCAN-52568abd-c509-411e-8391-c75e7613eb42

-- NOTES --
[*] In local database only "CVE" and "EDB" data is available

"""

FILE_LOCATION = Path(__file__).resolve()
HOME_DIR = FILE_LOCATION.parent
EXPLOITS_DIR = Path(f"{HOME_DIR}/Data")
EXPLOITS_CSV_PATH = f"{EXPLOITS_DIR}/files_exploits.csv"
EXPLOIT_DB_TAR_PATH = f"{EXPLOITS_DIR}/exploitdb-main.tar.gz"

software_names = [SoftwareName.CHROME.value]
operating_systems = [OperatingSystem.WINDOWS.value, OperatingSystem.LINUX.value]   
user_agent_rotator = UserAgent(software_names=software_names, operating_systems=operating_systems, limit=100)
UA = user_agent_rotator.get_random_user_agent()
HEADER = {"User-Agent": UA, "X-Requested-With": "XMLHttpRequest"}

session = requests.Session()
session.headers.update({"User-Agent": random.choice(UA), "X-Requested-With": "XMLHttpRequest"})

def print_message(message):
    info_tag = colorama.Fore.BLUE + "[INFO]" + colorama.Style.RESET_ALL
    colored_message = colorama.Fore.BLUE + message + colorama.Style.RESET_ALL
    print(f"{info_tag} {colored_message}")

def print_success(message):
    success_tag = colorama.Fore.GREEN + "[SUCCESS]" + colorama.Style.RESET_ALL
    colored_message = colorama.Fore.GREEN + message + colorama.Style.RESET_ALL
    print(f"{success_tag} {colored_message}")

def print_failure(message):
    failure_tag = colorama.Fore.RED + "[FAILURE]" + colorama.Style.RESET_ALL
    colored_message = colorama.Fore.RED + message + colorama.Style.RESET_ALL
    print(f"{failure_tag} {colored_message}")

def get_terminal_width():
    try:
        size = os.get_terminal_size()
        return size.columns
    except OSError:
        return 80

def wrap_text(text, width):
    return '\n'.join(textwrap.wrap(text, width))

def restart_program():
    try:
        python = sys.executable
        os.execl(python, python, * sys.argv)
    except Exception as e:
        print_failure(f"Failed to clear")

def do_update():
    print()
    print_message("Updating exploits database metadatas")
    try:
        gitlab_url = requests.get("https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv", headers=HEADER)
        with open(EXPLOITS_CSV_PATH, 'w') as outfile:
            outfile.write(gitlab_url.text)
        print_success(f"Metadata updated - {datetime.datetime.fromtimestamp(os.path.getmtime(EXPLOITS_CSV_PATH))}")
    except Exception as e:
        print_failure(f"Failed to update metadata: {e}")

    print_message("Updating exploits database")
    try:
        os.system(f"curl -s \"https://gitlab.com/exploit-database/exploitdb/-/archive/main/exploitdb-main.tar.gz?path=exploits\" -o {EXPLOIT_DB_TAR_PATH}")
        print_success(f"Exploits database updated - {datetime.datetime.fromtimestamp(os.path.getmtime(EXPLOIT_DB_TAR_PATH))}")

        with tarfile.open(EXPLOIT_DB_TAR_PATH) as tar_file:
            tar_file.extractall(EXPLOITS_DIR)
        print_success("New exploits extracted")
        print()
    except Exception as e:
        print_failure(f"Failed to update exploits database: {e}")
        print()

def do_critical():
    print()
    print_message("Looking for the latest critical CVEs")
    try:
        critical_url = requests.get("https://www.opencve.io/cve?cvss=critical&search=", headers=HEADER)
        criticals = re.findall(r"<strong>(CVE-.*)<\/strong>.*(?:\n.*?)+(?:(N\/A).*(?:\n.*?)+(N\/A).*?|vendor=(.*?)&product=(.*?)').*(?:\n.*?)+(\d{4}-\d{2}-\d{2}).*?(?:\n.*?(\d?\d.\d).*?|\n.*?)+<tr class=\"cve-summary\">\n.*colspan=\"5\">(.*)", critical_url.text)

        terminal_width = os.get_terminal_size().columns
        other_columns_width_estimate = 100
        max_description_width = max(30, terminal_width - other_columns_width_estimate)

        x = PrettyTable()
        x.field_names = ["CVE", "CVSS", "Vendor", "Product", "Description", "Update"]

        for critical in criticals:
            cvss = critical[6] if critical[6] else " "
            if cvss != " ":
                score = float(cvss)
                if score > 8.9:
                    cvss = colorama.Fore.RED + cvss + colorama.Style.RESET_ALL
                elif score > 6.9:
                    cvss = colorama.Fore.YELLOW + cvss + colorama.Style.RESET_ALL
                elif score > 3.9:
                    cvss = colorama.Fore.BLUE + cvss + colorama.Style.RESET_ALL
                else:
                    cvss = colorama.Fore.GREEN + cvss + colorama.Style.RESET_ALL

            wrapped_description = wrap_text(critical[7], max_description_width)

            row = [
                critical[0],
                cvss,
                critical[3].upper()[:20] if critical[3] else " ",
                critical[4][:20] if critical[4] else " ",
                wrapped_description,
                critical[5]
            ]
            x.add_row(row)
            
            divider = [' '] * len(x.field_names)
            x.add_row(divider)

        print(x)
        print_success("Got the latest critical CVEs")
        print()
    except Exception as e:
        print_failure(f"Failed to retrieve critical CVEs: {e}")
        print()


def do_search(arg):
    print()
    print_message(f"Looking for the latest {arg} CVEs")
    try:
        search_url = requests.get(f"https://www.opencve.io/cve?search={arg}", headers=HEADER)
        searches = re.findall("<strong>(CVE-.*)<\/strong>.*(?:\n.*?)+(?:(N\/A).*(?:\n.*?)+(N\/A).*?|vendor=(.*?)&product=(.*?)').*(?:\n.*?)+(\d{4}-\d{2}-\d{2}).*?(?:\n.*?(\d?\d.\d).*?|\n.*?)+<tr class=\"cve-summary\">\n.*colspan=\"5\">(.*)", search_url.text, re.IGNORECASE)

        terminal_width = os.get_terminal_size().columns
        other_columns_width_estimate = 100
        max_description_width = max(30, terminal_width - other_columns_width_estimate)

        x = PrettyTable()
        x.field_names = ["CVE", "CVSS", "Vendor", "Product", "Description", "Update"]

        for search in searches:
            score = " " if search[6] == "" else float(search[6])
            score_color = colorama.Fore.WHITE
            if score != " ":
                if score > 8.9:
                    score_color = colorama.Fore.RED
                elif score > 6.9:
                    score_color = colorama.Fore.YELLOW
                elif score > 3.9:
                    score_color = colorama.Fore.BLUE
                else:
                    score_color = colorama.Fore.GREEN
            score = score_color + str(score) + colorama.Style.RESET_ALL

            wrapped_description = wrap_text(search[7], max_description_width)
            x.add_row([search[0], score, search[3].upper()[:20], search[4][:20], wrapped_description, search[5]])
            x.add_row([' '*len(field) for field in x.field_names])

        print(x)
        print_success("Got the latest CVEs")
        print()
    except Exception as e:
        print_failure(f"Failed to retrieve CVEs: {e}")
        print()

    print_message(f"Looking for the latest {arg} exploits from local database")
    try:
        x = PrettyTable()
        x.field_names = ["EDB", "Language", "Description", "Author", "Release Date", "Update"]

        exploits_match = []
        with open(EXPLOITS_CSV_PATH, "r") as infile:
            for line in infile.readlines():
                if arg.casefold() in line.casefold():
                    exploits_match.append(line.strip())

        terminal_width = os.get_terminal_size().columns
        other_columns_and_padding_estimate = 20 * len(x.field_names) - x.field_names.index("Description") * 20
        description_width = max(30, terminal_width - other_columns_and_padding_estimate)

        for exploit in exploits_match:
            exploit_data = exploit.split(",")
            exploit_id, exploit_path, exploit_summ, exploit_rel_date, exploit_author, *_, exploit_update = exploit_data[:10]

            lang = "Unknown"
            if exploit_path.endswith(".cpp"):
                lang = colorama.Fore.CYAN + "C++" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".c"):
                lang = colorama.Fore.CYAN + "C" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".sh"):
                lang = colorama.Fore.GREEN + "Shell" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".rb"):
                lang = colorama.Fore.RED + "Ruby" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".pl"):
                lang = colorama.Fore.MAGENTA + "Perl" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".py"):
                lang = colorama.Fore.YELLOW + "Python" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".php"):
                lang = colorama.Fore.BLUE + "PHP" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".txt"):
                lang = colorama.Fore.WHITE + "Text" + colorama.Style.RESET_ALL
            elif exploit_path.endswith(".jsp"):
                lang = colorama.Fore.BLACK + "JSP" + colorama.Style.RESET_ALL

            wrapped_description = wrap_text(exploit_summ[:100].strip('"'), description_width)

            x.add_row([exploit_id, lang, wrapped_description, exploit_author.strip('"'), exploit_rel_date, exploit_update])
            x.add_row([' ' * len(field) for field in x.field_names])

        print(x)
        print_success("Got the latest exploits")
        print()
    except Exception as e:
        print_failure(f"Failed to retrieve exploits: {e}")
        print()

def do_get(arg):
    print()
    if not arg.startswith(("CVE", "EDB", "cve", "edb")):
        print("Local exploit is only available for CVE and EDB")
        return
    else:
        print_message("Finding local exploit from CVE-ID/EDB-ID")
        arg = arg.upper()
        if arg[:4] == "CVE-":
            print_message(f"Retrieving {arg} informations")
            try:
                search_url = session.get(f"https://www.opencve.io/cve/{arg}", headers=HEADER)
                search_summ = re.findall("<div class=\"box-body\">.*\n.*<span class=\"dropcap\">(.*?)\n.*<\/div>", search_url.text)
                print()
                print(colorama.Fore.RED + arg + colorama.Style.RESET_ALL + " " + search_summ[0].replace('</span>', ''))
                print()
            except Exception as e:
                print_failure("CVE not found.")
            print_message(f"Searching exploits for {arg}")
            try:
                cve = arg.strip("CVE-")
                cve_url = session.get(f"https://www.exploit-db.com/search?cve={cve}", headers=HEADER).json()
                cve_infos = json.dumps(cve_url, sort_keys=False, indent=4)
                cve_infos = json.loads(cve_infos)
                cve_infos = cve_infos['data']
                if cve_infos == []:
                    print_message("No exploit available yet in local database for this CVE")
                    print()
                else:
                    for i in range(len(cve_infos)):
                        cve_infos_edb = cve_infos[i]['id']
                        cve_infos_summ = cve_infos[i]['description'][1]
                        with open(f"{EXPLOITS_CSV_PATH}", "r") as infile:
                            for line in infile.readlines():
                                if cve_infos_edb == line.split(',')[0]:
                                    exploit = line.split(",")
                                    exploit_id = exploit[0]
                                    exploit_path = exploit[1]
                                    exploit_summ = exploit[2]
                                    exploit_rel_date = exploit[3]
                                    exploit_author = exploit[4]
                                    exploit_update = exploit[9]
                                    if exploit_path[-4:] == ".cpp":
                                        exploit_lang = colorama.Fore.CYAN + "c++" + colorama.Style.RESET_ALL
                                    elif exploit_path[-2:] == ".c":
                                        exploit_lang = colorama.Fore.CYAN + "c" + colorama.Style.RESET_ALL
                                    elif exploit_path[-3:] == ".sh":
                                        exploit_lang = colorama.Fore.GREEN + "sh" + colorama.Style.RESET_ALL
                                    elif exploit_path[-3:] == ".rb":
                                        exploit_lang = colorama.Fore.RED + "ruby" + colorama.Style.RESET_ALL
                                    elif exploit_path[-3:] == ".pl":
                                        exploit_lang = colorama.Fore.MAGENTA + "perl" + colorama.Style.RESET_ALL
                                    elif exploit_path[-3:] == ".py":
                                        exploit_lang = colorama.Fore.YELLOW + "python" + colorama.Style.RESET_ALL
                                    elif exploit_path[-4:] == ".php":
                                        exploit_lang = colorama.Fore.BLUE + "php" + colorama.Style.RESET_ALL
                                    elif exploit_path[-4:] == ".txt":
                                        exploit_lang = colorama.Fore.WHITE + "text" + colorama.Style.RESET_ALL
                                    elif exploit_path[-4:] == ".jsp":
                                        exploit_lang = colorama.Fore.BLACK + "jsp" + colorama.Style.RESET_ALL
                                    print(f"\t - Exploit EDB-ID: {cve_infos_edb}")
                                    print(f"\t - Exploit Name: {cve_infos_summ}")
                                    print(f"\t - Exploit Language: {exploit_lang}")
                                    print(f"\t - Exploit Author: " + exploit_author.strip('"'))
                                    print(f"\t - Exploit Release date: {exploit_rel_date}")
                                    print(f"\t - Exploit Last update: {exploit_update}")
                                    print(f"\t - Exploit Path: {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}")
                                    if exploit_lang == colorama.Fore.CYAN + "c" + colorama.Style.RESET_ALL or exploit_lang == colorama.Fore.CYAN + "c++" + colorama.Style.RESET_ALL:
                                        try:
                                            with open(f"{EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}", "r") as payload:
                                                payload = payload.read()
                                                compilation = re.search(r"((gcc|g\+\+) .*?)(\\r\\n|\\n)", payload).group(1)
                                                if compilation != '':
                                                    compilation = re.sub(' \S*\.cpp', f" {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}", compilation).strip("\"")
                                                    compilation = re.sub(' \S*\.c', f" {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}", compilation).strip("\"")
                                                    compilation = re.sub('-o \S*', f'-o /tmp/' + exploit_path.split('/')[-1].split(".")[0], compilation).strip("\"")
                                                    print_success(f"\t - Exploit compilation command: {compilation}")
                                        except:
                                                compilation = f"gcc {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path} -o /tmp/" + exploit_path.split('/')[-1].split(".")[0]
                                                print_failure(f"\t - Exploit compilation command not detected, default command: {compilation}")
                                    print()
                    print_success("Got exploit from local database")
            except Exception as e:
                    print_failure("No exploits available yet in the local database for this CVE.")

        elif arg[:4] == "EDB-":
            cves = []
            arg = arg.upper()
            print_message(f"Retrieving {arg} informations")
            try:
                edb = arg.strip("EDB-")
                edb_url = requests.get(f"https://www.exploit-db.com/exploits/{edb}", headers=HEADER)
                cve_names = re.findall("target=\"_blank\">.*\n(.*?-.*?)\n.*<\/a>", edb_url.text)
                for cve in cve_names:
                    cve = "CVE-" + cve.strip(' ')
                    cves.append(cve)
                if cve_names == []:
                    print_failure(f"No CVE found for EDB-{edb}")
                else:
                    
                    for cve in cves:
                        print_message(f"Retrieving {cve} informations")
                        try:
                            search_url = requests.get(f"https://www.opencve.io/cve/{cve}", headers=HEADER)
                            search_summ = re.findall("<div class=\"box-body\">.*\n.*<span class=\"dropcap\">(.*?)\n.*<\/div>", search_url.text)
                            print(colorama.Fore.RED + cve + colorama.Style.RESET_ALL + " " + search_summ[0].replace('</span>', ''))
                            print()
                        except Exception as e:
                            print_failure(e)
            except Exception as e:
                print_failure("No CVE founded for EDB-{edb}")

            print_message(f"Searching exploits in local database for {arg}")

            try:
                exploits_match = []
                edb = arg.strip("EDB-")
                with open(f"{EXPLOITS_CSV_PATH}", "r") as infile:
                    for line in infile.readlines():
                        if edb == line.split(',')[0]:
                            exploits_match.append(line)

                    for exploit in exploits_match:
                        exploit = exploit.split(",")
                        exploit_id = exploit[0]
                        exploit_path = exploit[1]
                        exploit_summ = exploit[2]
                        exploit_rel_date = exploit[3]
                        exploit_author = exploit[4]
                        exploit_update = exploit[9]
                        if exploit_path[-4:] == ".cpp":
                            exploit_lang = colorama.Fore.CYAN + "c++" + colorama.Style.RESET_ALL
                        elif exploit_path[-2:] == ".c":
                            exploit_lang = colorama.Fore.CYAN + "c" + colorama.Style.RESET_ALL
                        elif exploit_path[-3:] == ".sh":
                            exploit_lang = colorama.Fore.GREEN + "sh" + colorama.Style.RESET_ALL
                        elif exploit_path[-3:] == ".rb":
                            exploit_lang = colorama.Fore.RED + "ruby" + colorama.Style.RESET_ALL
                        elif exploit_path[-3:] == ".pl":
                            exploit_lang = colorama.Fore.MAGENTA + "perl" + colorama.Style.RESET_ALL
                        elif exploit_path[-3:] == ".py":
                            exploit_lang = colorama.Fore.YELLOW + "python" + colorama.Style.RESET_ALL
                        elif exploit_path[-4:] == ".php":
                            exploit_lang = colorama.Fore.BLUE + "php" + colorama.Style.RESET_ALL
                        elif exploit_path[-4:] == ".txt":
                            exploit_lang = colorama.Fore.WHITE + "text" + colorama.Style.RESET_ALL
                        elif exploit_path[-4:] == ".jsp":
                            exploit_lang = colorama.Fore.BLACK + "jsp" + colorama.Style.RESET_ALL
                        print(f"\t - Exploit EDB-ID : {exploit_id}")
                        print(f"\t - Exploit name : {exploit_summ}")
                        print(f"\t - Exploit language : {exploit_lang}")
                        print(f"\t - Exploit author : " + exploit_author.strip('"'))
                        print(f"\t - Exploit release date : {exploit_rel_date}")
                        print(f"\t - Exploit last update : {exploit_update}")
                        print(f"\t - Exploit path : {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}")
                        if exploit_lang == colorama.Fore.CYAN + "c" + colorama.Style.RESET_ALL or exploit_lang == colorama.Fore.CYAN + "c++" + colorama.Style.RESET_ALL:
                            try:
                                with open(f"{EXPLOITS_DIR}/exploitdb-main-exploits/" + exploit_path, "r") as payload:
                                    payload = payload.read()
                                    compilation = re.search(r"((gcc|g\+\+) .*?)(\r\n|\n)", payload).group(1)
                                    if compilation != '':
                                        compilation = re.sub(' \S*\.cpp', f" {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path[:-2]}", compilation).strip("\"")
                                        compilation = re.sub(' \S*\.c', f" {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path}", compilation).strip("\"")
                                        compilation = re.sub('-o \S*', '-o /tmp/' + exploit_path.split('/')[-1].split(".")[0], compilation).strip("\"")
                                        print_message(f"\t - Exploit compilation command: {compilation}")
                            except:
                                    compilation = f"gcc {EXPLOITS_DIR}/exploitdb-main-exploits/{exploit_path} -o /tmp/" + exploit_path.split('/')[-1].split(".")[0]
                                    print_failure(f"\t - Exploit compilation command not detected, default command: {compilation}")
                        print()
                print_success("Got exploit from local database")
            except Exception as e:
                print_failure(e)

        else:
            print("Usage: get <CVE-ID> or get <EDB-ID> to get exploit from local database")
            print()

def do_get_live(arg):
    if arg.startswith(("EDB", "edb")):
        return
    else:
        print()
        print_message("Finding exploit from internet")
        api_url = f"https://api.exploit.observer/?keyword={arg}"

        response = requests.get(api_url, headers=HEADER)

        if response.status_code == 200:

            data = response.json()
            x = PrettyTable()
            x.field_names = ["Language", "Link"]
            longest_link = max(max(len(link) for link in links) for links in data['entries'].values())

            terminal_width = get_terminal_width()

            language_column_width = max(len(language) for language in data['entries']) + 5
            available_width_for_link = terminal_width - language_column_width - 4 

            link_column_max_width = min(longest_link, available_width_for_link)
            x.max_width["Link"] = link_column_max_width

            language_colors = {
                "c++": colorama.Fore.CYAN,
                "c": colorama.Fore.CYAN,
                "shell": colorama.Fore.GREEN,
                "ruby": colorama.Fore.RED,
                "perl": colorama.Fore.MAGENTA,
                "python": colorama.Fore.YELLOW,
                "php": colorama.Fore.BLUE,
                "text": colorama.Fore.WHITE,
                "jsp": colorama.Fore.BLACK,
                "java": colorama.Fore.BLUE,
                "javascript": colorama.Fore.YELLOW,
                "typescript": colorama.Fore.BLUE,
                "html": colorama.Fore.MAGENTA,
                "css": colorama.Fore.BLUE,
                "go": colorama.Fore.CYAN,
                "rust": colorama.Fore.RED,
                "swift": colorama.Fore.MAGENTA,
                "kotlin": colorama.Fore.GREEN,
                "scala": colorama.Fore.RED,
                "lua": colorama.Fore.BLUE,
                "dart": colorama.Fore.GREEN,
                "r": colorama.Fore.BLUE,
                "sql": colorama.Fore.MAGENTA,
                "unknown": colorama.Fore.WHITE 
            }

            for language, links in data['entries'].items():
                color = language_colors.get(language, colorama.Fore.WHITE) 
                colored_language = color + language + colorama.Style.RESET_ALL
                
                for link in links:
                    x.add_row([colored_language, link])

            print(x)
            print_success("Got informations from internet")
            print()
        else:
            print(f"Failed to retrieve data: {response.status_code}")
            print()

def colorize(char):
    if char == ' ':
        return char
    else:
        return random.choice([Fore.RED, Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN]) + char

colored_ascii = ''.join(colorize(char) for char in exploit_finder_art)


def main():
    print(colored_ascii)
    print(Fore.WHITE + author_info)
    print(Fore.WHITE + github_info)
    print("   \n")

    while True:
        user_input = input("Enter command (help/update/critical/search/get/clear/exit): ").strip().lower()
        if user_input == "update":
            do_update()
        elif user_input == "critical":
            do_critical()
        elif user_input.startswith("search"):
            # Extracting the argument for the search command
            search_argument = user_input.split(" ", 1)[1].strip() if len(user_input.split(" ", 1)) > 1 else ""
            do_search(search_argument)
        elif user_input.startswith("get"):
            get_argument = user_input.split(" ", 1)[1].strip() if len(user_input.split(" ", 1)) > 1 else ""
            do_get(get_argument)
            do_get_live(get_argument)
        elif user_input == "help":
            print(usages)
        elif user_input == "clear":
            os.system('cls' if os.name == 'nt' else 'clear')
            restart_program()
        elif user_input == "exit":
            print_message("Exiting program")
            sys.exit()
        else:
            print_failure("Invalid command. Please enter 'help', update', 'critical', 'search', 'get', 'clear', or 'exit'")

if __name__ == "__main__":
    main()
